#!/usr/bin/env python
"""jss_helper

Command line utility using jss.py

Copyright (C) 2014 Shea G Craig <shea.craig@da.org>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""

import argparse
from distutils.version import StrictVersion
import re
import subprocess
import sys

import jss
try:
    from jss import __version__
except ImportError:
    __version__ = '0.0.0'


REQUIRED_PYTHON_JSS_VERSION = StrictVersion('0.3.4')


def print_object(objs):
    if isinstance(objs, list):
        for obj in objs:
            print "ID: %s\t\tNAME: %s" % (obj.id, obj.name)
    else:
        print objs


def create_func(obj_method):
    """Generates a function to perform basic list and xml queries."""
    def f(j, args):
        if args.id:
            id_ = int(args.id)
            try:
                results = obj_method(id_)
            except jss.JSSGetError:
                print "Object ID: %s does not exist!" % id_
                sys.exit(1)
        else:
            results = obj_method()
        print_object(results)

    return f


def get_group_policies(j, args):
    """Find all policies scoped to a group."""
    search = 'scope/computer_groups/computer_group'
    policies = j.Policy()
    group = j.ComputerGroup(args.group)
    results = find_object_in_containers(group, search, policies)
    output = build_results_string('Policies', args.group, results)
    print output


def get_package_policies(j, args):
    """Find all policies which install a package."""
    search = 'package_configuration/packages/package'
    policies = j.Policy()
    package = j.Package(args.package)
    results = find_object_in_containers(package, search, policies)
    output = build_results_string('Policies', args.package, results)
    print output


def find_object_in_containers(search_object, search_path, containers):
    """Get all container objects which contain a reference to an object.

    JSS Objects often reference other objects: e.g. Policies have
    scoping groups and packages. This function will search within a
    container-type JSS Object for a reference to another object.

    Args:
        search_object: A JSSObject to search for in objs.
        search_path: A xpath String to the list container to check for
            search object.
        containers: List of JSSObjects to check.

    Returns: A list of objects which match.
    """
    results = []
    full_objects = containers.retrieve_all()
    for obj in full_objects:
        for element in obj.findall(search_path):
            if (element.findtext('id') == search_object.id or
                element.findtext('name') == search_object.name):
                results.append((obj.id, obj.name))
    return results


def build_results_string(type, search, results):
    """Format a list of results for output reporting.

    Args:
        type: String name of type to use as a header.
        search: String name of the object matched.
        results: An iterable of match tuples, of (int ID, str name).

    Returns:
        Formatted report string.
    """
    s = "%s with %s:\n" % (type, search)
    for i in results:
        # TODO(Shea): Fix string building.
        s += "ID: %s\t\tNAME: %s\n" % (i[0], i[1])
    return s


def batch_scope(j, args):
    group = j.ComputerGroup(args.group)
    print "Scoping to group: %s" % group.name
    print 79 * '-'
    for policy_query in args.policies:
        policy = j.Policy(int(policy_query))
        policy.add_object_to_scope(group)
        policy.save()
        print "%s: Success." % policy.name


def get_md_configp_group(j, args):
    """Find all mobile device configuration profiles scoped to a group."""
    search = 'scope/mobile_device_groups/mobile_device_group'
    configps = j.MobileDeviceConfigurationProfile()
    group = j.MobileDeviceGroup(args.group)
    results = get_objects_by_scoped_group(configps, search, group)
    output = build_results_string('Profiles', args.group, results)
    print output


def get_group_policy_diff(j, args):
    search = 'scope/computer_groups/computer_group'
    policies = j.Policy()
    policies.sort()
    group1 = j.ComputerGroup(args.group1)
    group2 = j.ComputerGroup(args.group2)
    results1 = get_objects_by_scoped_group(policies, search, group1)
    results2 = get_objects_by_scoped_group(policies, search, group2)

    # I tried to do this with the tempfile module, but the files always ended
    # up being size 0 and dissappearing, despite delete=False.
    with open('/tmp/file1', mode='w') as f1:
        output = build_results_string("Policies", args.group1, results1)
        f1.write(output)
        file1 = f1.name
    with open('/tmp/file2', mode='w') as f2:
        output = build_results_string("Policies", args.group2, results2)
        f2.write(output)
        file2 = f2.name

    subprocess.call(['diff', '-y', file1, file2])


def promote(j, args):
    """Replace a package in a policy with another package.

    Designed with the intention of facilitating promotion from development
    to production of a package.
    """
    old_package = j.Package(args.old_package)
    new_package = j.Package(args.new_package)
    policy = j.Policy(args.policy)
    package_config = policy.find('package_configuration/packages')
    policy.remove_object_from_list(old_package, package_config)
    policy.add_package(new_package)
    # This is probably super situational for my organization...
    # Looks for the version number at the end of the name of the policy
    # (doesn't support anything but numbers and dots) and tries to sub it with
    # a version number from the package's name. I name all of our packages to
    # include the version number, so this works for me.
    if args.update_version_in_name:
        policy_name_element = policy.find('general/name')
        old_version = re.search(r'[\s\-]([0-9.]+)$',
                                policy_name_element.text).group(1)
        new_version = re.search(r'([0-9.]*[0-9]+)\.pkg$',
                                new_package.name).group(1)
        print old_version, new_version
        name = policy_name_element.text
        print "Old name: %s" % name
        name = name.replace(old_version, new_version)
        print "New name: %s" % name
        policy_name_element.text = name
    policy.save()


def get_md_configp_diff(j, args):
    search = 'scope/mobile_device_groups/mobile_device_group'
    profiles = j.MobileDeviceConfigurationProfile()
    group1 = j.MobileDeviceGroup(args.group1)
    group2 = j.MobileDeviceGroup(args.group2)
    results1 = get_objects_by_scoped_group(profiles, search, group1)
    results2 = get_objects_by_scoped_group(profiles, search, group2)

    # I tried to do this with the tempfile module, but the files always ended
    # up being size 0 and dissappearing, despite delete=False.
    with open('/tmp/file1', mode='w') as f1:
        output = build_results_string("Profiles", args.group1, results1)
        f1.write(output)
        file1 = f1.name
    with open('/tmp/file2', mode='w') as f2:
        output = build_results_string("Profiles", args.group2, results2)
        f2.write(output)
        file2 = f2.name

    subprocess.call(['diff', '-y', file1, file2])


def create_subparser(parser, name, help, func, **kwargs):
    """Create subparsers for our interface."""
    subparser = parser.add_parser(name, help=help)
    if kwargs:
        for arg_name, arg_help in kwargs.items():
            subparser.add_argument(arg_name, help=arg_help)
    subparser.set_defaults(func=func)


def main():
    """Run as a cli command."""

    # Ensure we have the right version of python-jss
    python_jss_version = StrictVersion(__version__)
    if python_jss_version < REQUIRED_PYTHON_JSS_VERSION:
        print "Requires python-jss version: %s. Installed: %s" % (
            (REQUIRED_PYTHON_JSS_VERSION, python_jss_version))
        sys.exit()

    jss_prefs = jss.JSSPrefs()
    j = jss.JSS(jss_prefs=jss_prefs)

    # Create our argument parser
    parser = argparse.ArgumentParser(description="Query the JSS.")
    parser.add_argument('-v', action='store_true', help="Verbose output.")
    parser.add_argument('--ssl', default=False, action='store_true',
                        help="Use SSL verification")
    subparser = parser.add_subparsers(dest='subparser_name')

    subparsers = {}

    # computer
    subparsers['computer'] = {
        'help': "Get a list of all computers, or an individual computer.",
        'func': create_func(j.Computer),
        'kwargs': {'--id': 'ID of computer to retrieve.'}}
    subparsers['group'] = {
        'help': "Get a list of all computer groups, or an individual group.",
        'func': create_func(j.ComputerGroup),
        'kwargs': {'--id': 'ID of computer group to retrieve.'}}
    subparsers['package'] = {
        'help': "Get a list of all packages' names and IDs, or the package "
                "XML.",
        'func': create_func(j.Package),
        'kwargs': {'--id': 'ID of policy to retrieve.',}}
    subparsers['policy'] = {
        'help': "Get a list of all policies' names and IDs, or the policy "
                "XML.",
        'func': create_func(j.Policy),
        'kwargs': {'--id': 'ID of policy to retrieve.',}}
    subparsers['policy_by_group'] = {
        'help': "Lists all policies scoped to provided group.",
        'func': get_group_policies,
        'kwargs': {'group': 'Group name to query.'}}
    subparsers['group_policy_diff'] = {
        'help': "Lists all policies scoped to two provided groups, "
                "highlighting the differences.",
        'func': get_group_policy_diff,
        'kwargs': {'group1': 'Group name to query.',
                   'group2': 'Group name to query.'}}
    subparsers['category'] = {
        'help': "Get a list of all categories' names and IDs.",
        'func': create_func(j.Category),
        'kwargs': {'--id': 'ID of category to retrieve.'}}
    subparsers['md'] = {
        'help': "Get a list of mobile devices, or find one by ID.",
        'func': create_func(j.MobileDevice),
        'kwargs': {'--id': 'ID of mobile device to retrieve.'}}
    subparsers['md_group'] = {
        'help': "Get a list of mobile device groups, or find one by ID.",
        'func': create_func(j.MobileDeviceGroup),
        'kwargs': {'--id': 'ID of mobile device group ' 'to retrieve.'}}
    subparsers['md_configp'] = {
        'help': "Get a list of mobile device configuration profiles, or find "
                "one by ID, ",
        'func': create_func(j.MobileDeviceConfigurationProfile),
        'kwargs': {'--id': "ID of mobile device configuration profile to "
                           "retrieve."}}
    subparsers['md_configp_by_group'] = {
        'help': "Lists all mobile configuration profiles scoped to provided "
                "group.",
        'func': get_md_configp_group,
        'kwargs': {'group': 'Group name to query.'}}
    subparsers['md_configp_diff'] = {
        'help': "Lists the differences between all mobile configuration "
                "profiles scoped to the provided groups.",
        'func': get_md_configp_diff,
        'kwargs': {'group1': 'Group name to query.',
                   'group2': 'Group name to query.'}}

    for name, d in subparsers.items():
        create_subparser(subparser, name, d['help'], d['func'], **d['kwargs'])

    # More complicated parsers.

    # Batch Scope
    help = "Scope a list of policies to a group."
    batch_scope_subparser = subparser.add_parser('batch_scope', help=help)
    batch_scope_subparser.add_argument('group', help="Name of group to scope "
                                       "policies.")
    help = "A space delimited list of policy IDs."
    batch_scope_subparser.add_argument('policies', help=help, nargs='*')
    batch_scope_subparser.set_defaults(func=batch_scope)

    # Promote
    help = "Promote a package from development to production by updating an" \
            " existing production policy with a newer package."
    promote_subparser = subparser.add_parser('promote', help=help)
    promote_subparser.add_argument('old_package', help='Package name or ID.')
    promote_subparser.add_argument('new_package', help='Package name or ID.')
    promote_subparser.add_argument('policy', help='Policy name or ID.')
    help = 'If policy name includes a package version number, update it ' \
            'with the new version number.'
    promote_subparser.add_argument('--update-version-in-name', help=help,
                                   action='store_true')
    promote_subparser.set_defaults(func=promote)

    args = parser.parse_args()
    if args.v:
        j.verbose = True
    # Until I add a toggle method...
    j.session.verify = args.ssl

    args.func(j, args)


if __name__ == '__main__':
    main()
