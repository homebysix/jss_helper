#!/usr/bin/env python
# Copyright (C) 2014-2015 Shea G Craig <shea.craig@da.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


"""jss_helper

Perform queries of objects on a JAMF Software Server.

Requires: python-jss.

usage: jss_helper [-h] [-v] [--ssl]  ...

Query the JSS.

optional arguments:
  -h, --help     show this help message and exit
  -v             Verbose output.
  --ssl          Use SSL verification

Actions:

    category     List all categories, or search for an individual category.
    computer     List all computers, or search for an individual computer.
    group        List all computer groups, or search for an individual group.
    installs     Lists all policies which install a package.
    md           List all mobile devices, or search for an indvidual mobile
                 device.
    md_configp   List all mobile device configuration profiles, or search for
                 an individual mobile device configuration profile.
    md_group     List all mobile device groups, or search for an individual
                 mobile device group.
    md_scope_diff
                 Show the differences between two mobile device groups' scoped
                 mobile device configuration profiles.
    md_scoped    List all mobile device configuration profiles scoped to a
                 mobile device group.
    package      List of all packages, or search for an individual package.
    policy       List all policies, or search for an individual policy.
    scope_diff   Show the difference between two groups' scoped policies.
    scoped       List all policies scoped to a computer group.
    batch_scope  Scope a list of policies to a group.
    promote      Promote a package from development to production by updating
                 an existing production policy with a newer package.
"""


import argparse
from distutils.version import StrictVersion, LooseVersion
from operator import itemgetter
import re
import subprocess
import sys

import jss


__version__ = "1.0.1"
REQUIRED_PYTHON_JSS_VERSION = StrictVersion("0.3.4")

# Utility Functions

def print_object(objs):
    """Flexible print method for lists and XML.

    Prints formatted lists of ID/NAME or the XML for an object.

    Args:
        objs: List of JSSObjects or a JSSObject.
    """
    # TODO(Shea): Refactor into build_results_string.
    if isinstance(objs, list):
        width = max([int(len(str(obj.id))) for obj in objs])
        results = []
        for obj in objs:
            results.append(u"ID: {:>{width}}\tNAME: {}".format(
                obj.id, obj.name, width=width))
        print "\n".join(results)
    else:
        print objs


def build_results_string(obj_type, search, results):
    """Format a list of results for output reporting.

    Args:
        obj_type: String name of type to use as a header.
        search: String name of the object matched.
        results: An iterable of match tuples, of (int ID, str name).

    Returns:
        Formatted report string.
    """
    output_string = "%s with %s:\n" % (obj_type, search)
    if results:
        width = max([int(len(result[0])) for result in results])
        output_strings = []
        for i in results:
            output_strings.append(u"ID: {:>{width}}\tNAME: {}".format(
                i[0], i[1], width=width))
        output_string += "\n".join(output_strings)
    else:
        output_string += "No results found."
    return output_string


def find_object_in_containers(search_object, search_path, containers):
    """Get all container objects which contain a reference to an object.

    JSS Objects often reference other objects: e.g. Policies have
    scoping groups and packages. This function will search within a
    container-type JSS Object for a reference to another object.

    Args:
        search_object: A JSSObject to search for in objs.
        search_path: A xpath String to the list container to check for
            search object.
        containers: List of JSSObjects to check.

    Returns: A list of tuples (object's ID, object's name) which match.
    """
    results = []
    full_objects = containers.retrieve_all()
    for obj in full_objects:
        for element in obj.findall(search_path):
            if (element.findtext("id") == search_object.id or
                    element.findtext("name") == search_object.name):
                results.append((obj.id, obj.name))
    return results


def _input_menu_text(expandable, flags):
    """Based on available options, build a series of prompts."""
    # Build the input menu text:
    input_menu_strings = ["\nEnter a number to select from list."]
    if expandable:
        input_menu_strings.append("Enter 'F' to expand the options list.")
    if flags and "DEFAULT" in flags:
        input_menu_strings.append("Hit <Enter> to accept default choice.")
    input_menu_strings.append("Please choose an object: ")
    return "\n".join(input_menu_strings)


def prompt_user(options, expandable=False, flags=None):
    """Ask user a question based on configured values.

    Args:
        options: Iterable of options to choose from.
        expandable: Optional iterable of options to choose from, larger
            than "options". If provided, will add an "F" option to the
            interactive menu which allows user to expand the possible
            selections.

            Defaults to an empty list, and will disable
            the "F" menu option.
        flags: Dynamically mark some options with extra
            text. For example, make an option "Default".

            Key: String name of text to append to option in list.
            Value: Function for matching an option. The function
                must return a bool.

            e.g.: {"CURRENT": lambda f: current_package in f}
                where "current_package" is a variable with the desired
                value.

            flags accepts a special key name: "DEFAULT", which will
            flag an option as a default, which is selectable by the
            user by simply pressing enter.

    Returns:
        The item chosen from the options iterable. Note, this does not
        include the flag text if present.
    """
    # In case the abbreviated option list is actually empty, go ahead
    # and use the expanded list.
    if not options:
        options = expandable
        expandable = False
    flagged_options = _add_flags_to_list(flags, options)
    display_options_list(flagged_options)

    # Ask user to select an option until they make a valid choice.
    result = None
    while not result:
        choice = raw_input(_input_menu_text(expandable, flags))
        if choice.isdigit() and in_range(int(choice), len(options)):
            result = options[int(choice)]
        elif choice.upper() == "F" and expandable:
            # User wants the full list.
            flagged_full_options = _add_flags_to_list(flags, expandable)
            display_options_list(flagged_full_options)
            options = expandable
            # Turn off expandable so the next loop won't continue to
            # allow the "F" option.
            expandable = False
        elif choice == "" and flags and "DEFAULT" in flags:
            results = [option for option in options if
                       flags["DEFAULT"](option)]
            # If there is a result, use it! Otherwise, just repeat the
            # menu.
            if results:
                result = results.pop()
        else:
            print "Invalid choice!"

    return result


def in_range(val, size):
    """Determine whether a value x is within the range 0 > x <= size."""
    return val < size and val >= 0


def sort_package_list(packages):
    """Sort a list of packages by version number.

    Args:
        packages: A list of string names that are formatted for
            get_package_info() usage.

    Returns:
        A list of string package names in order of
        distutils.version.LooseVersion
    """
    package_info = []
    for package in packages:
        pkg_name, pkg_string_version = get_package_info(package)
        # If the regex fails on either basename or version, skip.
        if pkg_name and pkg_string_version:
            # Upper the name for sorting, and convert version to a
            # LooseVersion.
            package_info.append((package, pkg_name.upper(),
                                 LooseVersion(pkg_string_version)))

    # Sort by name, then version.
    package_info.sort(key=itemgetter(1, 2))
    # Return just the original name.
    return [package[0] for package in package_info]


def display_options_list(options):
    """Prints options in columns as a numbered list.

    Optionally, flag some options with extra text.

    Args:
        options: Iterable of strings to enumerate, and print in
            columns.
    """
    # Justify the columns so the option numbers don't push the options
    # out of a nice left-justified column.

    # Figure out the number of options, then the length of that number.
    length = len(str(len(options))) + len("\t")
    fmt_string = u"{0[0]:>{length}}: {0[1]}"
    choices = "\n".join([fmt_string.format(option, length=length) for option in
                         enumerate(options)])
    print "\n" + choices


def build_argument_parser(j):
    """Build the argument parser for jss_helper.

    Args:
        j: A JSS object.

    Returns: A configured argparse parser.
    """
    # Create our argument parser
    parser = argparse.ArgumentParser(description="Query the JSS.")
    parser.add_argument("-v", action="store_true", help="Verbose output.")
    parser.add_argument("--ssl", default=False, action="store_true",
                        help="Use SSL verification")
    subparser = parser.add_subparsers(dest="subparser_name", title="Actions",
                                      metavar="")

    subparsers = {}

    # computer
    subparsers["computer"] = {
        "help": "List all computers, or search for an individual computer.",
        "func": create_search_func(j.Computer),
        "args": {"search": {"help": "ID or name of computer.",
                            "default": None,
                            "nargs": "?"}}}
    subparsers["group"] = {
        "help": "List all computer groups, or search for an individual group.",
        "func": create_search_func(j.ComputerGroup),
        "args": {"search": {"help": "ID or name of computer group.",
                            "default": None,
                            "nargs": "?"}}}
    subparsers["package"] = {
        "help": "List of all packages, or search for an individual package.",
        "func": create_search_func(j.Package),
        "args": {"search": {"help": "ID or name of package.",
                            "default": None,
                            "nargs": "?"}}}
    subparsers["policy"] = {
        "help": "List all policies, or search for an individual policy.",
        "func": create_search_func(j.Policy),
        "args": {"search": {"help": "ID or name of policy.",
                            "default": None,
                            "nargs": "?"}}}
    subparsers["scoped"] = {
        "help": "List all policies scoped to a computer group.",
        "func": get_group_policies,
        "args": {"group": {"help": "ID or name of a computer group."}}}
    subparsers["installs"] = {
        "help": "Lists all policies which install a package.",
        "func": get_package_policies,
        "args": {"package": {"help": "ID or name of a package."}}}
    subparsers["scope_diff"] = {
        "help": "Show the difference between two groups' scoped policies.",
        "func": get_group_policy_diff,
        "args": {"group1": {"help": "ID or name of first group."},
                 "group2": {"help": "ID or name of second group."}}}
    subparsers["category"] = {
        "help": "List all categories, or search for an individual category.",
        "func": create_search_func(j.Category),
        "args": {"search": {"help": "ID or name of category.",
                            "default": None,
                            "nargs": "?"}}}
    subparsers["md"] = {
        "help": "List all mobile devices, or search for an indvidual mobile "
                "device.",
        "func": create_search_func(j.MobileDevice),
        "args": {"search": {"help": "ID or name of mobile device.",
                            "default": None,
                            "nargs": "?"}}}
    subparsers["md_group"] = {
        "help": "List all mobile device groups, or search for an individual "
                "mobile device group.",
        "func": create_search_func(j.MobileDeviceGroup),
        "args": {"search": {"help": "ID or name of mobile device group.",
                            "default": None,
                            "nargs": "?"}}}
    subparsers["md_configp"] = {
        "help": "List all mobile device configuration profiles, or search for "
                "an individual mobile device configuration profile.",
        "func": create_search_func(j.MobileDeviceConfigurationProfile),
        "args": {"search": {"help": "ID or name of mobile device configuration"
                                    " profile.",
                            "default": None,
                            "nargs": "?"}}}
    subparsers["md_scoped"] = {
        "help": "List all mobile device configuration profiles scoped to a "
                "mobile device group.",
        "func": get_md_configp_group,
        "args": {"group": {"help": "ID or name of a mobile device group."}}}
    subparsers["md_scope_diff"] = {
        "help": "Show the differences between two mobile device groups' "
                "scoped mobile device configuration profiles.",
        "func": get_md_configp_diff,
        "args": {"group1": {"help": "ID or name of first group."},
                 "group2": {"help": "ID or name of second group."}}}

    sorted_subparsers = sorted(subparsers)
    for command in sorted_subparsers:
        sub = subparser.add_parser(command, help=subparsers[command]["help"],
                                   description=subparsers[command]["help"])
        for arg in subparsers[command]["args"]:
            sub.add_argument(arg, **subparsers[command]["args"][arg])
        sub.set_defaults(func=subparsers[command]["func"])

    # More complicated parsers.

    # Batch Scope
    arg_help = "Scope a list of policies to a group."
    batch_scope_subparser = subparser.add_parser(
        "batch_scope", help=arg_help, description=arg_help)
    batch_scope_subparser.add_argument(
        "group", help="Name of group to scope policies.")
    arg_help = "A space delimited list of policy IDs."
    batch_scope_subparser.add_argument("policy", help=arg_help, nargs="*")
    batch_scope_subparser.set_defaults(func=batch_scope)

    # Promote
    arg_help = ("Promote a package from development to production by updating "
                "an existing production policy with a newer package.")
    promote_subparser = subparser.add_parser(
        "promote", help=arg_help, description=arg_help)
    promote_subparser.add_argument("policy", help="Policy name or ID.",
                                   nargs="?", default=None)
    promote_subparser.add_argument("new_package", help="Package name or ID.",
                                   nargs="?", default=None)
    arg_help = ("Update the package version number in the policy's name. "
                "The Policy name must include the exact product name and the "
                "version. The package extension is optional, and will not be "
                "modified. Text replacement also ignores '-', '_', and ' ' "
                "(space) between the name and version. e.g.: 'jss_helper "
                "promote \"Install Nethack-3.4.3\" Nethack-3.4.4' will result "
                "in the policy name: 'Install Nethack-3.4.4'. See the README "
                "for further examples and more details.")
    promote_subparser.add_argument("-u", "--update_name", help=arg_help,
                                   action="store_true")
    promote_subparser.set_defaults(func=promote)

    return parser


def create_search_func(obj_method):
    """Generates a function to perform basic list and xml queries.

    Args:
        args: argparser args with properties:
            search: Name or ID of object to search for.
    """
    # pylint: disable=unused-argument
    def search_func(j, args):
        """Searches JSS for all objects OR a specific object."""
        try:
            results = obj_method(args.search)
        except jss.JSSGetError:
            print "Object: %s does not exist!" % args.search
            sys.exit(1)
        print_object(results)
    # pylint: enable=unused-argument

    return search_func


def get_package_info(package_name):
    """Return the package basename and version as a tuple."""
    # Match a string comprised of one or more alphanumeric characters,
    # whitespace, hyphens, or underscores
    package_regex = (r"(?P<basename>[\w\s\-]+)[\s\-]"
                     r"(?P<version>[\d.]+[a-zA-Z]*)\."
                     r"(?P<extension>pkg|dmg|zip)$")
    match = re.search(package_regex, package_name)
    if match:
        result = match.group("basename", "version")
    else:
        result = (None, None)
    return result


def update_name(policy, cur_pkg_name, new_pkg_name):
    """Try to update policy name with package info.

    Try to replace the product name and version in the policy's name
    with the new values.

    Changes passed policy object if possible; otherwise raises an
    exception.

    Args:
        policy: A Policy object to update.
        cur_pkg_name: String name of the current package.
        new_pkg_name: String name of the updated package.

    Raises:
        Exception: One or more of the arguments were not formatted
            correctly for text replacement to occur.
    """
    policy_name_element = policy.find("general/name")
    cur_pkg_basename, cur_pkg_version = get_package_info(cur_pkg_name)
    new_pkg_basename, new_pkg_version = get_package_info(new_pkg_name)

    changes = [cur_pkg_basename, cur_pkg_version, new_pkg_basename,
               new_pkg_version]
    if all(changes):
        name = policy_name_element.text
        new_name = name.replace(cur_pkg_basename, new_pkg_basename)
        new_name = new_name.replace(cur_pkg_version, new_pkg_version)
        print "Old name: %s" % name
        print "New name: %s" % new_name
        policy_name_element.text = new_name
    else:
        raise ValueError("Unable to update policy name!")


def get_newest_pkg(options):
    """Get the newest package from a list of a packages.

    Args:
        options: List of package names.

    Returns: Either the newest package name or None. Package names
        must be in some format that get_package_info() can extract a
        version number.
    """
    versions = {get_package_info(package)[1]: package for package
                in options if get_package_info(package)[1]}
    if versions:
        newest = max([LooseVersion(version) for version in versions])
        result = versions[str(newest)]
    else:
        result = None

    return result


def log_warning(policy):
    """Print warning about flushing the logs if triggers in policy."""
    if policy.findtext("general/frequency") != "Ongoing":
        triggers = ["trigger_checkin", "trigger_enrollment_complete",
                    "trigger_login", "trigger_logout",
                    "trigger_network_state_changed", "trigger_startup",
                    "trigger_other"]
        for trigger in triggers:
            value = policy.findtext("general/" + trigger)
            # Value can be string "false" or "" for "trigger_other".
            if value not in [None, "False"]:
                print "Remember to flush the policy logs!"
                break


def _build_package_version_dict(j):
    """Build a dictionary of package products with multiple versions.

    Args:
        j: A JSS object

    Returns:
        A dictionary of packages with multiple versions on the server:
            key: Package basename (string)
            value: List of package versions of type
                distutil.version.LooseVersion
    """
    packages = [package.name for package in j.Package()]
    package_version_dict = {}
    for package in packages:
        package_name, package_version = get_package_info(package)
        # Convert string version to something we can cmp.
        if package_name:
            if package_name not in package_version_dict:
                package_version_dict[package_name] = [
                    LooseVersion(package_version)]
            else:
                package_version_dict[package_name].append(
                    LooseVersion(package_version))

    # Narrow down packages list to only products which have multiple
    # packages on the JSS.
    multiples = {package: package_version_dict[package] for package in
                 package_version_dict if
                 len(package_version_dict[package]) > 1}
    return multiples


def _get_updatable_policies(j, policies):
    """Get a list of policies where newer pkg versions are available.

    Packages must have names which can be successfully split into
    product name and version with get_package_info().

    Args:
        j: A JSS object.
        policies: A list of Policy objects.

    Returns:
        A list of strings; the names of policies which install a
        package that is older than another package available on the
        JSS.
    """
    multiples = _build_package_version_dict(j)

    # For each policy, lookup any packages it installs in the multiples
    # dictionary and see if there is a newer version available.
    updates_available = []
    search = "package_configuration/packages/package/name"
    for policy in policies:
        packages_installed = [package.text for package in
                              policy.findall(search)]
        for package in packages_installed:
            pkg_name, pkg_version = get_package_info(package)
            if pkg_name in multiples:
                if LooseVersion(pkg_version) < max(multiples[pkg_name]):
                    updates_available.append(policy)
                    break

    # Make a new list of just names (rather than the full XML)
    updates_available_names = [policy.findtext("general/name") for policy in
                               updates_available]

    return updates_available_names


def _add_flags_to_list(flags, options):
    """Add a set of flags to options which match.

    See the documentation for ask_user() for full details.

        Args:
            flags: Dynamically mark some options with extra
                text. For example, make an option "Default".

                Key: String name of text to append to option in list.
                Value: Function for matching an option. The function
                    must return a bool.

                e.g.: {"CURRENT": lambda f: current_package in f}
                    where "current_package" is a variable with the desired
                    value.

            options: A list of strings to append text to.

        Returns:
            A list of flagged options. It does not mutate "options".
    """
    # Copy list to make sure we don't mutate any values.
    flagged_options = list(options)
    if flags:
        # Make a list of matches, then append text to each match.
        for flag in flags:
            matches = [option for option in flagged_options if
                       flags[flag](option)]
            for match in matches:
                flagged_options[flagged_options.index(match)] += " (%s)" % flag
    return flagged_options


# Actions
def get_group_policies(j, args):
    """Print all policies scoped to a group.

    Args:
        args: argparser args with properties:
            group: Name or ID of computer group.
    """
    search = "scope/computer_groups/computer_group"
    policies = j.Policy()
    group = j.ComputerGroup(args.group)
    results = find_object_in_containers(group, search, policies)
    output = build_results_string("Policies", group.name, results)
    print output


def get_package_policies(j, args):
    """Print all policies which install a package.

    Args:
        args: argparser args with properties:
            package: Name or ID of package.
    """
    search = "package_configuration/packages/package"
    policies = j.Policy()
    package = j.Package(args.package)
    results = find_object_in_containers(package, search, policies)
    output = build_results_string("Policies", package.name, results)
    print output


def get_md_configp_group(j, args):
    """Print all mobile device config profiles scoped to a group.

    Args:
        args: argparser args with properties:
            group: Name or ID of group.
    """
    search = "scope/mobile_device_groups/mobile_device_group"
    configps = j.MobileDeviceConfigurationProfile()
    group = j.MobileDeviceGroup(args.group)
    results = find_object_in_containers(group, search, configps)
    output = build_results_string("Profiles", args.group, results)
    print output


def get_group_policy_diff(j, args):
    """Print a diff of all policies scoped to two different groups.

    Args:
        args: argparser args with properties:
            group1: Name or ID of first computer group.
            group2: Name or ID of second computer group.
    """
    search = "scope/computer_groups/computer_group"
    policies = j.Policy()
    policies.sort()
    group1 = j.ComputerGroup(args.group1)
    group2 = j.ComputerGroup(args.group2)
    results1 = find_object_in_containers(group1, search, policies)
    results2 = find_object_in_containers(group2, search, policies)

    # I tried to do this with the tempfile module, but the files always
    # ended up being size 0 and dissappearing, despite delete=False.
    with open("/tmp/file1", mode="w") as file1:
        output = build_results_string("Policies", group1.name, results1)
        # Add a newline to keep diff from complaining.
        file1.write(output + "\n")
        file1_name = file1.name
    with open("/tmp/file2", mode="w") as file2:
        output = build_results_string("Policies", group2.name, results2)
        # Add a newline to keep diff from complaining.
        file2.write(output + "\n")
        file2_name = file2.name

    # Diff will return 1 if files differ, so we have to catch that
    # error.
    try:
        result = subprocess.check_output(
            ["diff", "-dy", file1_name, file2_name])
    except subprocess.CalledProcessError as err:
        result = err.output

    print result


def get_md_configp_diff(j, args):
    """Print a diff of all configuration profiles scoped to two groups.

    Args:
        args: argparser args with properties:
            group1: Name or ID of first group.
            group2: Name or ID of second group.
    """
    search = "scope/mobile_device_groups/mobile_device_group"
    profiles = j.MobileDeviceConfigurationProfile()
    group1 = j.MobileDeviceGroup(args.group1)
    group2 = j.MobileDeviceGroup(args.group2)
    results1 = find_object_in_containers(group1, search, profiles)
    results2 = find_object_in_containers(group2, search, profiles)

    # I tried to do this with the tempfile module, but the files always
    # ended up being size 0 and dissappearing, despite delete=False.
    with open("/tmp/file1_name", mode="w") as file1:
        output = build_results_string("Profiles", group1.name, results1)
        # Add a newline to keep diff from complaining.
        file1.write(output + "\n")
        file1_name = file1.name
    with open("/tmp/file2_name", mode="w") as file2:
        output = build_results_string("Profiles", group2.name, results2)
        # Add a newline to keep diff from complaining.
        file2.write(output + "\n")
        file2_name = file2.name

    # Diff will return 1 if files differ, so we have to catch that
    # error.
    try:
        result = subprocess.check_output(
            ["diff", "-dy", file1_name, file2_name])
    except subprocess.CalledProcessError as err:
        result = err.output

    print result


def batch_scope(j, args):
    """Scope a list of policies to a computer group.

    Args:
        args: argparser args with properties:
            group: Name or ID of computer group.
            policy: List of ID's or names of policies to scope.
    """
    group = j.ComputerGroup(args.group)
    print "Scoping to group: %s" % group.name
    print 79 * "-"
    for policy_query in args.policy:
        policy = j.Policy(policy_query)
        policy.add_object_to_scope(group)
        policy.save()
        print "%s: Success." % policy.name


# pylint: disable=too-many-locals
def promote(j, args):
    """Replace a package in a policy with another package.

    Designed with the intention of facilitating promotion from
    development to production of a package.

    If any arg is missing, an interactive menu will be displayed.

    Args:
        args: argparser args with properties:
            new_package: ID or name of package to install.
            policy: Name or ID of policy.
            update_name: Bool, Will atttempt to update the policy name
                with the new package name (minus the extension). e.g.
                "Install NetHack-3.4.3" will result in "Install
                NetHack-3.4.4".

                The policy name must include the exact package name,
                and version number for this to do anything.
    """
    if args.policy:
        policy = j.Policy(args.policy)
    else:
        # Interactive policy menu
        print ("No policy specified in args: Building a list of policies which "
               "have newer packages available...")
        # Get full policy XML for all policies.
        policy_list = j.Policy()
        print "Retrieving %i policies. Please wait..." % len(policy_list)
        all_policies = policy_list.retrieve_all()

        # Get lists of policies with available updates, and all
        # policies which install packages.
        with_updates = _get_updatable_policies(j, all_policies)
        install_policies = [
            policy.name for policy in all_policies if
            int(policy.findtext("package_configuration/packages/size")) > 0]

        policy_name = prompt_user(with_updates, expandable=install_policies)
        policy = j.Policy(policy_name)

    cur_pkg = policy.findtext("package_configuration/packages/package/name")
    cur_pkg_basename, _ = get_package_info(cur_pkg)

    if args.new_package:
        new_pkg_name = args.new_package
    else:
        # Interactive package menu.

        # Build a list of ALL packages.
        full_options = [package.name for package in j.Package()]
        # Build a list of packages with same product name as policy.
        matching_options = [option for option in full_options if
                            cur_pkg_basename and cur_pkg_basename.upper() in
                            option.upper()]

        # Sort the package lists by name, then version.
        sorted_full_options = sort_package_list(full_options)
        sorted_matching_options = sort_package_list(matching_options)

        # Build flags for menu.
        flags = {"CURRENT": lambda f: cur_pkg in f}
        default = get_newest_pkg(matching_options)
        if default:
            flags["DEFAULT"] = lambda f: default in f

        new_pkg_name = prompt_user(
            sorted_matching_options, expandable=sorted_full_options,
            flags=flags)

    policy.remove_object_from_list(cur_pkg, "package_configuration/packages")
    policy.add_package(j.Package(new_pkg_name))

    if args.update_name:
        try:
            update_name(policy, cur_pkg, new_pkg_name)
        except ValueError:
            print "Unable to update policy name!"

    policy.save()
    log_warning(policy)
# pylint: enable=too-many-locals


def main():
    """Run as a cli command."""
    # Ensure we have the right version of python-jss
    try:
        python_jss_version = StrictVersion(jss.__version__)
    except AttributeError:
        python_jss_version = StrictVersion("0.0.0")

    if python_jss_version < REQUIRED_PYTHON_JSS_VERSION:
        print "Requires python-jss version: %s. Installed: %s" % (
            (REQUIRED_PYTHON_JSS_VERSION, python_jss_version))
        sys.exit()

    jss_prefs = jss.JSSPrefs()
    j = jss.JSS(jss_prefs=jss_prefs)

    parser = build_argument_parser(j)
    args = parser.parse_args()
    if args.v:
        j.verbose = True
    # Until I add a toggle method...
    j.session.verify = args.ssl

    args.func(j, args)


if __name__ == "__main__":
    main()
