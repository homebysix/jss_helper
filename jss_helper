#!/usr/bin/env python
"""jss_helper

Command line utility using jss.py

Copyright (C) 2014 Shea G Craig <shea.craig@da.org>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""

import argparse
from distutils.version import StrictVersion
import re
import subprocess
import sys

import jss


__version__ = "1.0.1"
REQUIRED_PYTHON_JSS_VERSION = StrictVersion("0.3.4")


def print_object(objs):
    """Flexible print method for lists and XML.

    Prints formatted lists of ID/NAME or the XML for an object.

    Args:
        objs: List of JSSObjects.
    """
    # TODO(Shea): Refactor into build_results_string.
    if isinstance(objs, list):
        #for obj in objs:
        #    print "ID: %s\t\tNAME: %s" % (obj.id, obj.name)
        width = max([int(len(str(obj.id))) for obj in objs])
        results = []
        for obj in objs:
            results.append(u"ID: {:>{width}}\tNAME: {}".format(
                obj.id, obj.name, width=width))
                #obj.id, obj.name.encode("utf8"), width=width))
        print "\n".join(results)
    else:
        print objs


def build_results_string(type, search, results):
    """Format a list of results for output reporting.

    Args:
        type: String name of type to use as a header.
        search: String name of the object matched.
        results: An iterable of match tuples, of (int ID, str name).

    Returns:
        Formatted report string.
    """
    output_string = "%s with %s:\n" % (type, search)
    if results:
        width = max([int(len(result[0])) for result in results])
        output_strings = []
        for i in results:
            output_strings.append(u"ID: {:>{width}}\tNAME: {}".format(
                i[0], i[1], width=width))
        output_string += "\n".join(output_strings)
    else:
        output_string += "No results found."
    return output_string


def get_group_policies(j, args):
    """Find all policies scoped to a group."""
    search = "scope/computer_groups/computer_group"
    policies = j.Policy()
    group = j.ComputerGroup(args.group)
    results = find_object_in_containers(group, search, policies)
    output = build_results_string("Policies", group.name, results)
    print output


def get_package_policies(j, args):
    """Find all policies which install a package."""
    search = "package_configuration/packages/package"
    policies = j.Policy()
    package = j.Package(args.package)
    results = find_object_in_containers(package, search, policies)
    output = build_results_string("Policies", package.name, results)
    print output


def find_object_in_containers(search_object, search_path, containers):
    """Get all container objects which contain a reference to an object.

    JSS Objects often reference other objects: e.g. Policies have
    scoping groups and packages. This function will search within a
    container-type JSS Object for a reference to another object.

    Args:
        search_object: A JSSObject to search for in objs.
        search_path: A xpath String to the list container to check for
            search object.
        containers: List of JSSObjects to check.

    Returns: A list of objects which match.
    """
    results = []
    full_objects = containers.retrieve_all()
    for obj in full_objects:
        for element in obj.findall(search_path):
            if (element.findtext("id") == search_object.id or
                    element.findtext("name") == search_object.name):
                results.append((obj.id, obj.name))
    return results


def batch_scope(j, args):
    group = j.ComputerGroup(args.group)
    print "Scoping to group: %s" % group.name
    print 79 * "-"
    for policy_query in args.policies:
        policy = j.Policy(int(policy_query))
        policy.add_object_to_scope(group)
        policy.save()
        print "%s: Success." % policy.name


def get_md_configp_group(j, args):
    """Find all mobile device configuration profiles scoped to a group."""
    search = "scope/mobile_device_groups/mobile_device_group"
    configps = j.MobileDeviceConfigurationProfile()
    group = j.MobileDeviceGroup(args.group)
    results = get_objects_by_scoped_group(configps, search, group)
    output = build_results_string("Profiles", args.group, results)
    print output


def get_group_policy_diff(j, args):
    search = "scope/computer_groups/computer_group"
    policies = j.Policy()
    policies.sort()
    group1 = j.ComputerGroup(args.group1)
    group2 = j.ComputerGroup(args.group2)
    results1 = find_object_in_containers(group1, search, policies)
    results2 = find_object_in_containers(group2, search, policies)

    # I tried to do this with the tempfile module, but the files always ended
    # up being size 0 and dissappearing, despite delete=False.
    with open("/tmp/file1", mode="w") as f1:
        output = build_results_string("Policies", group1.name, results1)
        # Add a newline to keep diff from complaining.
        f1.write(output + "\n")
        file1 = f1.name
    with open("/tmp/file2", mode="w") as f2:
        output = build_results_string("Policies", group2.name, results2)
        # Add a newline to keep diff from complaining.
        f2.write(output + "\n")
        file2 = f2.name

    # Diff will return 1 if files differ, so we have to catch that error.
    try:
        result = subprocess.check_output(["diff", "-dy", file1, file2])
    except subprocess.CalledProcessError as err:
        result = err.output

    print result


def promote(j, args):
    """Replace a package in a policy with another package.

    Designed with the intention of facilitating promotion from development
    to production of a package.
    """
    old_package = j.Package(args.old_package)
    new_package = j.Package(args.new_package)
    policy = j.Policy(args.policy)
    package_config = policy.find("package_configuration/packages")
    policy.remove_object_from_list(old_package, package_config)
    policy.add_package(new_package)
    # This is probably super situational for my organization...
    # Looks for the version number at the end of the name of the policy
    # (doesn't support anything but numbers and dots) and tries to sub it with
    # a version number from the package's name. I name all of our packages to
    # include the version number, so this works for me.
    if args.update_version_in_name:
        policy_name_element = policy.find("general/name")
        old_version = re.search(r"[\s\-]([0-9.]+)$",
                                policy_name_element.text).group(1)
        new_version = re.search(r"([0-9.]*[0-9]+)\.pkg$",
                                new_package.name).group(1)
        print old_version, new_version
        name = policy_name_element.text
        print "Old name: %s" % name
        name = name.replace(old_version, new_version)
        print "New name: %s" % name
        policy_name_element.text = name
    policy.save()


def get_md_configp_diff(j, args):
    search = "scope/mobile_device_groups/mobile_device_group"
    profiles = j.MobileDeviceConfigurationProfile()
    group1 = j.MobileDeviceGroup(args.group1)
    group2 = j.MobileDeviceGroup(args.group2)
    results1 = get_objects_by_scoped_group(profiles, search, group1)
    results2 = get_objects_by_scoped_group(profiles, search, group2)

    # I tried to do this with the tempfile module, but the files always ended
    # up being size 0 and dissappearing, despite delete=False.
    with open("/tmp/file1", mode="w") as f1:
        output = build_results_string("Profiles", args.group1, results1)
        f1.write(output)
        file1 = f1.name
    with open("/tmp/file2", mode="w") as f2:
        output = build_results_string("Profiles", args.group2, results2)
        f2.write(output)
        file2 = f2.name

    subprocess.call(["diff", "-y", file1, file2])


def build_argument_parser(j):
    """Build the argument parser for jss_helper.

    Args:
        j: A JSS object.

    Returns: A configured argparse parser.
    """
    # Create our argument parser
    parser = argparse.ArgumentParser(description="Query the JSS.")
    parser.add_argument("-v", action="store_true", help="Verbose output.")
    parser.add_argument("--ssl", default=False, action="store_true",
                        help="Use SSL verification")
    subparser = parser.add_subparsers(dest="subparser_name")

    subparsers = {}

    # computer
    subparsers["computer"] = {
        "help": "Get a list of all computers, or an individual computer.",
        "func": create_search_func(j.Computer),
        "args": {"search": {"help": "ID or name of computer to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["group"] = {
        "help": "Get a list of all computer groups, or an individual group.",
        "func": create_search_func(j.ComputerGroup),
        "args": {"search": {"help": "ID or name of computer group to "
                                    "retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["package"] = {
        "help": "Get a list of all packages' names and IDs, or the package "
                "XML.",
        "func": create_search_func(j.Package),
        "args": {"search": {"help": "ID or name of package to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["policy"] = {
        "help": "Get a list of all policies' names and IDs, or the policy "
                "XML.",
        "func": create_search_func(j.Policy),
        "args": {"search": {"help": "ID or name of policy to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["policies_with_group"] = {
        "help": "Lists all policies scoped to provided group.",
        "func": get_group_policies,
        "args": {"group": {"help": "Group name to query."}}}
    subparsers["policies_with_package"] = {
        "help": "Lists all policies which install a package.",
        "func": get_package_policies,
        "args": {"package": {"help": "Package name or ID to query."}}}
    subparsers["group_policy_diff"] = {
        "help": "Lists all policies scoped to two provided groups, "
                "highlighting the differences.",
        "func": get_group_policy_diff,
        "args": {"group1": {"help": "Group name to query."},
                 "group2": {"help": "Group name to query."}}}
    subparsers["category"] = {
        "help": "Get a list of all categories' names and IDs.",
        "func": create_search_func(j.Category),
        "args": {"search": {"help": "ID or name of category to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["md"] = {
        "help": "Get a list of mobile devices, or find one by ID.",
        "func": create_search_func(j.MobileDevice),
        "args": {"search": {"help": "ID or name of mobile device to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["md_group"] = {
        "help": "Get a list of mobile device groups, or find one by ID.",
        "func": create_search_func(j.MobileDeviceGroup),
        "args": {"search": {"help": "ID or name of mobile device group to "
                                    "retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["md_configp"] = {
        "help": "Get a list of mobile device configuration profiles, or find "
                "one by ID, ",
        "func": create_search_func(j.MobileDeviceConfigurationProfile),
        "args": {"search": {"help": "ID or name of mobile device configuration"
                                    " profile to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["md_configp_by_group"] = {
        "help": "Lists all mobile configuration profiles scoped to provided "
                "group.",
        "func": get_md_configp_group,
        "args": {"group": {"help": "Group name to query."}}}
    subparsers["md_configp_diff"] = {
        "help": "Lists the differences between all mobile configuration "
                "profiles scoped to the provided groups.",
        "func": get_md_configp_diff,
        "args": {"group1": {"help": "Group name to query."},
                 "group2": {"help": "Group name to query."}}}

    for command in subparsers:
        sub = subparser.add_parser(command, help=subparsers[command]["help"])
        for arg in subparsers[command]["args"]:
            sub.add_argument(arg, **subparsers[command]["args"][arg])
        sub.set_defaults(func=subparsers[command]["func"])

    # More complicated parsers.

    # Batch Scope
    help = "Scope a list of policies to a group."
    batch_scope_subparser = subparser.add_parser("batch_scope", help=help)
    batch_scope_subparser.add_argument("group", help="Name of group to scope "
                                       "policies.")
    help = "A space delimited list of policy IDs."
    batch_scope_subparser.add_argument("policies", help=help, nargs="*")
    batch_scope_subparser.set_defaults(func=batch_scope)

    # Promote
    help = "Promote a package from development to production by updating an" \
            " existing production policy with a newer package."
    promote_subparser = subparser.add_parser("promote", help=help)
    promote_subparser.add_argument("old_package", help="Package name or ID.")
    promote_subparser.add_argument("new_package", help="Package name or ID.")
    promote_subparser.add_argument("policy", help="Policy name or ID.")
    help = "If policy name includes a package version number, update it " \
            "with the new version number."
    promote_subparser.add_argument("--update-version-in-name", help=help,
                                   action="store_true")
    promote_subparser.set_defaults(func=promote)

    return parser


def create_search_func(obj_method):
    """Generates a function to perform basic list and xml queries."""
    # TODO(Shea): Make the search term be an optional, repeatable arg.
    def f(j, args):
        if args.search:
            try:
                results = obj_method(args.search)
            except jss.JSSGetError:
                print "Object: %s does not exist!" % args.search
                sys.exit(1)
        else:
            results = obj_method()
        print_object(results)

    return f


def main():
    """Run as a cli command."""

    # Ensure we have the right version of python-jss
    try:
        python_jss_version = StrictVersion(jss.__version__)
    except AttributeError:
        python_jss_version = StrictVersion("0.0.0")

    if python_jss_version < REQUIRED_PYTHON_JSS_VERSION:
        print "Requires python-jss version: %s. Installed: %s" % (
            (REQUIRED_PYTHON_JSS_VERSION, python_jss_version))
        sys.exit()

    jss_prefs = jss.JSSPrefs()
    j = jss.JSS(jss_prefs=jss_prefs)

    parser = build_argument_parser(j)
    args = parser.parse_args()
    if args.v:
        j.verbose = True
    # Until I add a toggle method...
    j.session.verify = args.ssl

    args.func(j, args)


if __name__ == "__main__":
    main()
