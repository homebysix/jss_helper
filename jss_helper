#!/usr/bin/env python
# Copyright (C) 2014-2015 Shea G Craig <shea.craig@da.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


"""jss_helper

Perform queries of objects on a JAMF Software Server.

Requires: python-jss.

usage: jss_helper [-h] [-v] [--ssl]
                  {category,group_policy_diff,group,package,
                  policies_with_group,policies_with_package,md,computer,
                  md_configp_diff,md_configp,policy,md_group,
                  md_configp_by_group,batch_scope,promote}
                  ...

Query the JSS.

positional arguments:
  {category,group_policy_diff,group,package,policies_with_group,
  policies_with_package,md,computer,md_configp_diff,md_configp,policy,
  md_group,md_configp_by_group,batch_scope,promote}

    category            Get a list of all categories' names and IDs.
    group_policy_diff   Lists all policies scoped to two provided
                        groups, highlighting the differences.
    group               Get a list of all computer groups, or an
                        individual group.
    package             Get a list of all packages' names and IDs, or
                        the package XML.
    policies_with_group
                        Lists all policies scoped to provided group.
    policies_with_package
                        Lists all policies which install a package.
    md                  Get a list of mobile devices, or find one by ID.
    computer            Get a list of all computers, or an individual
                        computer.
    md_configp_diff     Lists the differences between all mobile
                        configuration profiles scoped to the provided
                        groups.
    md_configp          Get a list of mobile device configuration
                        profiles, or find one by ID,
    policy              Get a list of all policies' names and IDs, or
                        the policy XML.
    md_group            Get a list of mobile device groups, or find one
                        by ID.
    md_configp_by_group
                        Lists all mobile configuration profiles scoped
                        to provided group.
    batch_scope         Scope a list of policies to a group.
    promote             Promote a package from development to production
                        by updating an existing production policy with a
                        newer package.

optional arguments:
  -h, --help            show this help message and exit
  -v                    Verbose output.
  --ssl                 Use SSL verification
"""


import argparse
from distutils.version import StrictVersion
import re
import subprocess
import sys

import jss


__version__ = "1.0.1"
REQUIRED_PYTHON_JSS_VERSION = StrictVersion("0.3.4")


def print_object(objs):
    """Flexible print method for lists and XML.

    Prints formatted lists of ID/NAME or the XML for an object.

    Args:
        objs: List of JSSObjects.
    """
    # TODO(Shea): Refactor into build_results_string.
    if isinstance(objs, list):
        width = max([int(len(str(obj.id))) for obj in objs])
        results = []
        for obj in objs:
            results.append(u"ID: {:>{width}}\tNAME: {}".format(
                obj.id, obj.name, width=width))
        print "\n".join(results)
    else:
        print objs


def build_results_string(obj_type, search, results):
    """Format a list of results for output reporting.

    Args:
        type: String name of type to use as a header.
        search: String name of the object matched.
        results: An iterable of match tuples, of (int ID, str name).

    Returns:
        Formatted report string.
    """
    output_string = "%s with %s:\n" % (obj_type, search)
    if results:
        width = max([int(len(result[0])) for result in results])
        output_strings = []
        for i in results:
            output_strings.append(u"ID: {:>{width}}\tNAME: {}".format(
                i[0], i[1], width=width))
        output_string += "\n".join(output_strings)
    else:
        output_string += "No results found."
    return output_string


def get_group_policies(j, args):
    """Find all policies scoped to a group."""
    search = "scope/computer_groups/computer_group"
    policies = j.Policy()
    group = j.ComputerGroup(args.group)
    results = find_object_in_containers(group, search, policies)
    output = build_results_string("Policies", group.name, results)
    print output


def get_package_policies(j, args):
    """Find all policies which install a package."""
    search = "package_configuration/packages/package"
    policies = j.Policy()
    package = j.Package(args.package)
    results = find_object_in_containers(package, search, policies)
    output = build_results_string("Policies", package.name, results)
    print output


def find_object_in_containers(search_object, search_path, containers):
    """Get all container objects which contain a reference to an object.

    JSS Objects often reference other objects: e.g. Policies have
    scoping groups and packages. This function will search within a
    container-type JSS Object for a reference to another object.

    Args:
        search_object: A JSSObject to search for in objs.
        search_path: A xpath String to the list container to check for
            search object.
        containers: List of JSSObjects to check.

    Returns: A list of objects which match.
    """
    results = []
    full_objects = containers.retrieve_all()
    for obj in full_objects:
        for element in obj.findall(search_path):
            if (element.findtext("id") == search_object.id or
                    element.findtext("name") == search_object.name):
                results.append((obj.id, obj.name))
    return results


def batch_scope(j, args):
    """Scope a list of policies to a computer group.

    Args:
        args: argparser args with properties:
            group: Name or ID of computer group.
            policies: List of type int ID's of policies to scope.
    """
    group = j.ComputerGroup(args.group)
    print "Scoping to group: %s" % group.name
    print 79 * "-"
    for policy_query in args.policies:
        policy = j.Policy(int(policy_query))
        policy.add_object_to_scope(group)
        policy.save()
        print "%s: Success." % policy.name


def get_md_configp_group(j, args):
    """Find all mobile device config profiles scoped to a group."""
    search = "scope/mobile_device_groups/mobile_device_group"
    configps = j.MobileDeviceConfigurationProfile()
    group = j.MobileDeviceGroup(args.group)
    results = find_object_in_containers(group, search, configps)
    output = build_results_string("Profiles", args.group, results)
    print output


def get_group_policy_diff(j, args):
    """Find and diff all of the policies scoped to two different groups.

    Args:
        args: argparser args with properties:
            group1: Name or ID of first computer group.
            group2: Name or ID of second computer group.
    """
    search = "scope/computer_groups/computer_group"
    policies = j.Policy()
    policies.sort()
    group1 = j.ComputerGroup(args.group1)
    group2 = j.ComputerGroup(args.group2)
    results1 = find_object_in_containers(group1, search, policies)
    results2 = find_object_in_containers(group2, search, policies)

    # I tried to do this with the tempfile module, but the files always
    # ended up being size 0 and dissappearing, despite delete=False.
    with open("/tmp/file1", mode="w") as file1:
        output = build_results_string("Policies", group1.name, results1)
        # Add a newline to keep diff from complaining.
        file1.write(output + "\n")
        file1_name = file1.name
    with open("/tmp/file2", mode="w") as file2:
        output = build_results_string("Policies", group2.name, results2)
        # Add a newline to keep diff from complaining.
        file2.write(output + "\n")
        file2_name = file2.name

    # Diff will return 1 if files differ, so we have to catch that
    # error.
    try:
        result = subprocess.check_output(
            ["diff", "-dy", file1_name, file2_name])
    except subprocess.CalledProcessError as err:
        result = err.output

    print result


def promote(j, args):
    """Replace a package in a policy with another package.

    Designed with the intention of facilitating promotion from
    development to production of a package.
    """
    old_package = j.Package(args.old_package)
    new_package = j.Package(args.new_package)
    policy = j.Policy(args.policy)
    package_config = policy.find("package_configuration/packages")
    policy.remove_object_from_list(old_package, package_config)
    policy.add_package(new_package)
    # This is probably super situational for my organization...
    # Looks for the version number at the end of the name of the policy
    # (doesn't support anything but numbers and dots) and tries to sub
    # it with
    # a version number from the package's name. I name all of our
    # packages to include the version number, so this works for me.
    if args.update_version_in_name:
        policy_name_element = policy.find("general/name")
        old_version = re.search(r"[\s\-]([0-9.]+)$",
                                policy_name_element.text).group(1)
        new_version = re.search(r"([0-9.]*[0-9]+)\.pkg$",
                                new_package.name).group(1)
        print old_version, new_version
        name = policy_name_element.text
        print "Old name: %s" % name
        name = name.replace(old_version, new_version)
        print "New name: %s" % name
        policy_name_element.text = name
    policy.save()


def get_md_configp_diff(j, args):
    """Find and diff all configuration profiles scoped to two groups.

    Args:
        args: argparser args with properties:
            group1: Name or ID of first group.
            group2: Name or ID of second group.
    """
    search = "scope/mobile_device_groups/mobile_device_group"
    profiles = j.MobileDeviceConfigurationProfile()
    group1 = j.MobileDeviceGroup(args.group1)
    group2 = j.MobileDeviceGroup(args.group2)
    results1 = find_object_in_containers(group1, search, profiles)
    results2 = find_object_in_containers(group2, search, profiles)

    # I tried to do this with the tempfile module, but the files always
    # ended up being size 0 and dissappearing, despite delete=False.
    with open("/tmp/file1_name", mode="w") as file1:
        output = build_results_string("Profiles", group1.name, results1)
        # Add a newline to keep diff from complaining.
        file1.write(output + "\n")
        file1_name = file1.name
    with open("/tmp/file2_name", mode="w") as file2:
        output = build_results_string("Profiles", group2.name, results2)
        # Add a newline to keep diff from complaining.
        file2.write(output + "\n")
        file2_name = file2.name

    # Diff will return 1 if files differ, so we have to catch that
    # error.
    try:
        result = subprocess.check_output(
            ["diff", "-dy", file1_name, file2_name])
    except subprocess.CalledProcessError as err:
        result = err.output

    print result


def build_argument_parser(j):
    """Build the argument parser for jss_helper.

    Args:
        j: A JSS object.

    Returns: A configured argparse parser.
    """
    # Create our argument parser
    parser = argparse.ArgumentParser(description="Query the JSS.")
    parser.add_argument("-v", action="store_true", help="Verbose output.")
    parser.add_argument("--ssl", default=False, action="store_true",
                        help="Use SSL verification")
    subparser = parser.add_subparsers(dest="subparser_name")

    subparsers = {}

    # computer
    subparsers["computer"] = {
        "help": "Get a list of all computers, or an individual computer.",
        "func": create_search_func(j.Computer),
        "args": {"search": {"help": "ID or name of computer to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["group"] = {
        "help": "Get a list of all computer groups, or an individual group.",
        "func": create_search_func(j.ComputerGroup),
        "args": {"search": {"help": "ID or name of computer group to "
                                    "retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["package"] = {
        "help": "Get a list of all packages' names and IDs, or the package "
                "XML.",
        "func": create_search_func(j.Package),
        "args": {"search": {"help": "ID or name of package to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["policy"] = {
        "help": "Get a list of all policies' names and IDs, or the policy "
                "XML.",
        "func": create_search_func(j.Policy),
        "args": {"search": {"help": "ID or name of policy to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["policies_with_group"] = {
        "help": "Lists all policies scoped to provided group.",
        "func": get_group_policies,
        "args": {"group": {"help": "Group name to query."}}}
    subparsers["policies_with_package"] = {
        "help": "Lists all policies which install a package.",
        "func": get_package_policies,
        "args": {"package": {"help": "Package name or ID to query."}}}
    subparsers["group_policy_diff"] = {
        "help": "Lists all policies scoped to two provided groups, "
                "highlighting the differences.",
        "func": get_group_policy_diff,
        "args": {"group1": {"help": "Group name to query."},
                 "group2": {"help": "Group name to query."}}}
    subparsers["category"] = {
        "help": "Get a list of all categories' names and IDs.",
        "func": create_search_func(j.Category),
        "args": {"search": {"help": "ID or name of category to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["md"] = {
        "help": "Get a list of mobile devices, or find one by ID.",
        "func": create_search_func(j.MobileDevice),
        "args": {"search": {"help": "ID or name of mobile device to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["md_group"] = {
        "help": "Get a list of mobile device groups, or find one by ID.",
        "func": create_search_func(j.MobileDeviceGroup),
        "args": {"search": {"help": "ID or name of mobile device group to "
                                    "retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["md_configp"] = {
        "help": "Get a list of mobile device configuration profiles, or find "
                "one by ID, ",
        "func": create_search_func(j.MobileDeviceConfigurationProfile),
        "args": {"search": {"help": "ID or name of mobile device configuration"
                                    " profile to retrieve.",
                            "default": "",
                            "nargs": "?"}}}
    subparsers["md_configp_by_group"] = {
        "help": "Lists all mobile configuration profiles scoped to provided "
                "group.",
        "func": get_md_configp_group,
        "args": {"group": {"help": "Group name to query."}}}
    subparsers["md_configp_diff"] = {
        "help": "Lists the differences between all mobile configuration "
                "profiles scoped to the provided groups.",
        "func": get_md_configp_diff,
        "args": {"group1": {"help": "Group name to query."},
                 "group2": {"help": "Group name to query."}}}

    for command in subparsers:
        sub = subparser.add_parser(command, help=subparsers[command]["help"])
        for arg in subparsers[command]["args"]:
            sub.add_argument(arg, **subparsers[command]["args"][arg])
        sub.set_defaults(func=subparsers[command]["func"])

    # More complicated parsers.

    # Batch Scope
    arg_help = "Scope a list of policies to a group."
    batch_scope_subparser = subparser.add_parser("batch_scope", help=arg_help)
    batch_scope_subparser.add_argument("group", help="Name of group to scope "
                                       "policies.")
    arg_help = "A space delimited list of policy IDs."
    batch_scope_subparser.add_argument("policies", help=arg_help, nargs="*")
    batch_scope_subparser.set_defaults(func=batch_scope)

    # Promote
    arg_help = ("Promote a package from development to production by updating "
                "an existing production policy with a newer package.")
    promote_subparser = subparser.add_parser("promote", help=arg_help)
    promote_subparser.add_argument("old_package", help="Package name or ID.")
    promote_subparser.add_argument("new_package", help="Package name or ID.")
    promote_subparser.add_argument("policy", help="Policy name or ID.")
    arg_help = ("If policy name includes a package version number, update it "
                "with the new version number.")
    promote_subparser.add_argument("--update-version-in-name", help=arg_help,
                                   action="store_true")
    promote_subparser.set_defaults(func=promote)

    return parser


def create_search_func(obj_method):
    """Generates a function to perform basic list and xml queries."""
    # TODO(Shea): Make the search term be an optional, repeatable arg.
    # pylint: disable=unused-argument
    def search_func(j, args):
        """Searches JSS for all objects OR a specific object."""
        if args.search:
            try:
                results = obj_method(args.search)
            except jss.JSSGetError:
                print "Object: %s does not exist!" % args.search
                sys.exit(1)
        else:
            results = obj_method()
        print_object(results)
    # pylint: enable=unused-argument

    return search_func


def main():
    """Run as a cli command."""

    # Ensure we have the right version of python-jss
    try:
        python_jss_version = StrictVersion(jss.__version__)
    except AttributeError:
        python_jss_version = StrictVersion("0.0.0")

    if python_jss_version < REQUIRED_PYTHON_JSS_VERSION:
        print "Requires python-jss version: %s. Installed: %s" % (
            (REQUIRED_PYTHON_JSS_VERSION, python_jss_version))
        sys.exit()

    jss_prefs = jss.JSSPrefs()
    j = jss.JSS(jss_prefs=jss_prefs)

    parser = build_argument_parser(j)
    args = parser.parse_args()
    if args.v:
        j.verbose = True
    # Until I add a toggle method...
    j.session.verify = args.ssl

    args.func(j, args)


if __name__ == "__main__":
    main()
